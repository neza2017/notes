Hi:
I'm afraid there is an inner bug in the GPU hardware. this is my test program:

//=========== switch_test.cu ==================
#include <cuda.h>
#include <cuda_runtime.h>
#include <iostream>
#include <vector>

extern "C" __global__ void switch_test(long *src_ptr, long *dst_ptr, int num_rows, int* output_rows)
{
    int idx;
    long val;
    int pos_start = blockIdx.x * blockDim.x + threadIdx.x;
    if(pos_start >= num_rows) return;
    val = src_ptr[pos_start];
    switch(val){
        case 7016889694419943424L:
        case 3688448094816436224L:
        case 3761631588761206784L:
        case 7089228763434582016L:
        case 7161567832449220608L:{
			idx = atomicAdd(output_rows,1);
			dst_ptr[idx] = val;
			break;
		}
        default: break;
	}
	return;
}

int main()
{
    int64_t *src_ptr,*dst_ptr;
	int32_t num_rows = 10;
	auto cuda_err = cudaMallocManaged(&src_ptr,sizeof(int64_t)*num_rows);
	if(cuda_err) return -6;
	std::cout << "alloc src_ptr success" << std::endl;

	cuda_err = cudaMallocManaged(&dst_ptr,sizeof(int64_t)*num_rows);
	if(cuda_err) return -7;
	std::cout << "alloc dst_ptr success" << std::endl;

	int32_t* output_rows;
	cuda_err = cudaMallocManaged(&output_rows,sizeof(int32_t));

	// for(int i=0;i<num_rows;++i) src_ptr[i] = i;
	src_ptr[0] = 3688729569793146880L;
	src_ptr[1] = 3617516400685350912L;
	src_ptr[2] = 3688729569793146880L;
	src_ptr[3] = 3761631588761206784L;
	src_ptr[4] = 3688448094816436224L;
	src_ptr[5] = 3689292519746568192L;
	src_ptr[6] = 3618642300592193536L;
	src_ptr[7] = 3618360825615482880L;
	src_ptr[8] = 3688729569793146880L;
	src_ptr[9] = 3617516400685350912L;
	*output_rows = 0;

    switch_test<<<2,16>>>(src_ptr,dst_ptr,num_rows,output_rows);
    cudaDeviceSynchronize();
    cuda_err = cudaGetLastError();
    if(cuda_err){
        std::cout << "cudaDeviceSynchronize failed, error code = " << cuda_err << std::endl;
	}
	std::cout << "cudaDeviceSynchronize success" << std::endl;

    for(int i=0; i<*output_rows; ++i){
		std::cout << i << ":" << dst_ptr[i] << std::endl;
	}
    return 0;
}
//=========== end of swtich_test.cu =============

I use this command to compile switch_test.cu:
nvcc --gpu-architecture=sm_60 switch_test.cu -O3 -std=c++11 -o switch_test.nvcc

the output of switch_test.nvcc expected to be:
//=============== expected output of switch_test.nvcc =========
alloc src_ptr success
alloc dst_ptr success
cudaDeviceSynchronize success
0:3761631588761206784
1:3688448094816436224
//============== end of expected output of switch_test.nvcc ===========

but the real output of switch_test.nvcc is:
//================= real output of switch_test.nvcc =============
alloc src_ptr success
alloc dst_ptr success
cudaDeviceSynchronize success
0:3688729569793146880
1:3617516400685350912
2:3688729569793146880
3:3761631588761206784
4:3688448094816436224
5:3689292519746568192
6:3618642300592193536
7:3618360825615482880
8:3688729569793146880
9:3617516400685350912
//================ end of real output of switch_test.nvcc =============

At the very first time, I thought there might be a bug in the nvcc compiler.
Then I compile the switch_test.cu to get PTX file, use this command:
nvcc --gpu-code=sm_60 -arch compute_60 -ptx switch_test.cu -std=c++11 -o switch_test.ptx
//============== switch_test.ptx =======================
//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-22781540
// Cuda compilation tools, release 9.0, V9.0.176
// Based on LLVM 3.4svn
//

.version 6.0
.target sm_60
.address_size 64

	// .globl	switch_test

.visible .entry switch_test(
	.param .u64 switch_test_param_0,
	.param .u64 switch_test_param_1,
	.param .u32 switch_test_param_2,
	.param .u64 switch_test_param_3
)
{
	.reg .pred 	%p<8>;
	.reg .b32 	%r<7>;
	.reg .b64 	%rd<12>;


	ld.param.u64 	%rd2, [switch_test_param_0];
	ld.param.u64 	%rd3, [switch_test_param_1];
	ld.param.u32 	%r2, [switch_test_param_2];
	ld.param.u64 	%rd4, [switch_test_param_3];
	mov.u32 	%r3, %ntid.x;
	mov.u32 	%r4, %ctaid.x;
	mov.u32 	%r5, %tid.x;
	mad.lo.s32 	%r1, %r3, %r4, %r5;
	setp.ge.s32	%p1, %r1, %r2;
	@%p1 bra 	BB0_8;

	cvta.to.global.u64 	%rd5, %rd2;
	mul.wide.s32 	%rd6, %r1, 8;
	add.s64 	%rd7, %rd5, %rd6;
	ld.global.u64 	%rd1, [%rd7];
	setp.gt.s64	%p2, %rd1, 7016889694419943423;
	@%p2 bra 	BB0_4;

	setp.eq.s64	%p6, %rd1, 3688448094816436224;
	@%p6 bra 	BB0_7;

	setp.eq.s64	%p7, %rd1, 3761631588761206784;
	@%p7 bra 	BB0_7;
	bra.uni 	BB0_8;

BB0_4:
	setp.eq.s64	%p3, %rd1, 7016889694419943424;
	@%p3 bra 	BB0_7;

	setp.eq.s64	%p4, %rd1, 7089228763434582016;
	@%p4 bra 	BB0_7;

	setp.ne.s64	%p5, %rd1, 7161567832449220608;
	@%p5 bra 	BB0_8;

BB0_7:
	cvta.to.global.u64 	%rd8, %rd3;
	cvta.to.global.u64 	%rd9, %rd4;
	atom.global.add.u32 	%r6, [%rd9], 1;
	mul.wide.s32 	%rd10, %r6, 8;
	add.s64 	%rd11, %rd8, %rd10;
	st.global.u64 	[%rd11], %rd1;

BB0_8:
	ret;
}
//====================== end of switch_test.ptx ================

After reading the switch_test.ptx file ,I thought there is nothing wrong in the switch_test.ptx.
Then I write another program switch_test.cpp, to load the PTX file and do the launch kernel job in the switch_test.cpp.
//================== switch_test.cpp =====================
#include <cuda.h>
#include <cuda_runtime.h>
#include <iostream>
#include <vector>

int main()
{
	auto err = cuInit(0);
	if(err) return -1;

	CUdevice device;
	CUcontext context;

	err = cuDeviceGet(&device,0);
	if(err) return -2;

	err = cuCtxCreate(&context,CU_CTX_SCHED_BLOCKING_SYNC,device);
	if(err) return -3;
	std::cout << "cuda initial success" << std::endl;

	CUmodule module;
	err = cuModuleLoad(&module,"switch_test.ptx");
	if(err) return -4;
	std::cout << "cuda load module success" << std::endl;

	CUfunction function;
	err = cuModuleGetFunction(&function,module,"switch_test");
	if(err)return -5;
	std::cout << "cuda get function success" << std::endl;

	int64_t *src_ptr,*dst_ptr;
	int32_t num_rows = 10;
	auto cuda_err = cudaMallocManaged(&src_ptr,sizeof(int64_t)*num_rows);
	if(cuda_err) return -6;
	std::cout << "alloc src_ptr success" << std::endl;

	cuda_err = cudaMallocManaged(&dst_ptr,sizeof(int64_t)*num_rows);
	if(cuda_err) return -7;
	std::cout << "alloc dst_ptr success" << std::endl;

	int32_t* output_rows;
	cuda_err = cudaMallocManaged(&output_rows,sizeof(int32_t));

	// for(int i=0;i<num_rows;++i) src_ptr[i] = i;
	src_ptr[0] = 3688729569793146880L;
	src_ptr[1] = 3617516400685350912L;
	src_ptr[2] = 3688729569793146880L;
	src_ptr[3] = 3761631588761206784L;
	src_ptr[4] = 3688448094816436224L;
	src_ptr[5] = 3689292519746568192L;
	src_ptr[6] = 3618642300592193536L;
	src_ptr[7] = 3618360825615482880L;
	src_ptr[8] = 3688729569793146880L;
	src_ptr[9] = 3617516400685350912L;
	*output_rows = 0;

	void *kernel_para[]={
		&src_ptr,
		&dst_ptr,
		&num_rows,
		&output_rows
	};

	err=cuLaunchKernel(function,
			   2,1,1,
			   16,1,1,
			   0,nullptr,
			   (void**)&kernel_para,
			   nullptr);
	if(err) return -8;
	std::cout << "cuda launch kernel success" << std::endl;
	err = cuCtxSynchronize();
	if(err){
		std::cout << "context synchronize failed, error code = " << err << std::endl;
	}
	std::cout << "cuda context synchronize sucess" << std::endl;

	for(int i=0; i<*output_rows; ++i){
		std::cout << i << ":" << dst_ptr[i] << std::endl;
	}

	return 0;	
}
//========================== end of switch_test.cpp ===============

I use this command to compile the switch_test.cpp:
clang++ switch_test.cpp -o switch_test -std=c++11 -I/usr/local/cuda/include -L/usr/local/cuda/lib64 -lcuda -lcudart
execute the switch_test, it also prints the incorrect result:
//=========== incorrect output of switch_test =========
cuda initial success
cuda load module success
cuda get function success
alloc src_ptr success
alloc dst_ptr success
cuda launch kernel success
cuda context synchronize sucess
0:3688729569793146880
1:3617516400685350912
2:3688729569793146880
3:3761631588761206784
4:3688448094816436224
5:3689292519746568192
6:3618642300592193536
7:3618360825615482880
8:3688729569793146880
9:3617516400685350912
//========= end of incorrect output of switch_test ==========

After that, I insert one load command in the switch_test.ptx , this the new switch_test.ptx:
//=================== new switch_test.ptx ========================
//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-22781540
// Cuda compilation tools, release 9.0, V9.0.176
// Based on LLVM 3.4svn
//

.version 6.0
.target sm_60
.address_size 64

	// .globl	switch_test

.visible .entry switch_test(
	.param .u64 switch_test_param_0,
	.param .u64 switch_test_param_1,
	.param .u32 switch_test_param_2,
	.param .u64 switch_test_param_3
)
{
	.reg .pred 	%p<8>;
	.reg .b32 	%r<7>;
	.reg .b64 	%rd<12>;


	ld.param.u64 	%rd2, [switch_test_param_0];
	ld.param.u64 	%rd3, [switch_test_param_1];
	ld.param.u32 	%r2, [switch_test_param_2];
	ld.param.u64 	%rd4, [switch_test_param_3];
	mov.u32 	%r3, %ntid.x;
	mov.u32 	%r4, %ctaid.x;
	mov.u32 	%r5, %tid.x;
	mad.lo.s32 	%r1, %r3, %r4, %r5;
	setp.ge.s32	%p1, %r1, %r2;
	@%p1 bra 	BB0_8;

	cvta.to.global.u64 	%rd5, %rd2;
	mul.wide.s32 	%rd6, %r1, 8;
	add.s64 	%rd7, %rd5, %rd6;
	ld.global.u64 	%rd1, [%rd7];
	setp.gt.s64	%p2, %rd1, 7016889694419943423;
	@%p2 bra 	BB0_4;

	//==========================================================
	//=========== insert load command at this point ============

	ld.global.u64 	%rd1, [%rd7];
	
	//=========== end of insert load command ===================
	//==========================================================

	setp.eq.s64	%p6, %rd1, 3688448094816436224;
	@%p6 bra 	BB0_7;

	setp.eq.s64	%p7, %rd1, 3761631588761206784;
	@%p7 bra 	BB0_7;
	bra.uni 	BB0_8;

BB0_4:
	setp.eq.s64	%p3, %rd1, 7016889694419943424;
	@%p3 bra 	BB0_7;

	setp.eq.s64	%p4, %rd1, 7089228763434582016;
	@%p4 bra 	BB0_7;

	setp.ne.s64	%p5, %rd1, 7161567832449220608;
	@%p5 bra 	BB0_8;

BB0_7:
	cvta.to.global.u64 	%rd8, %rd3;
	cvta.to.global.u64 	%rd9, %rd4;
	atom.global.add.u32 	%r6, [%rd9], 1;
	mul.wide.s32 	%rd10, %r6, 8;
	add.s64 	%rd11, %rd8, %rd10;
	st.global.u64 	[%rd11], %rd1;

BB0_8:
	ret;
}
//=================== end of switch_test.ptx =================

After insert the load command, execute switch_test again to load the ptx and do the launch kernel, it prints the correct result:
//=========== correct output of switch_test =========
cuda initial success
cuda load module success
cuda get function success
alloc src_ptr success
alloc dst_ptr success
cuda launch kernel success
cuda context synchronize sucess
0:3761631588761206784
1:3688448094816436224
//========== end correct output of switch_test ============

I have test this program on 1060,1080,and v100, all these kinds of gpu prints incorrectly.
So, I think there is an inner bug in the gpu hardware.
looking forward to your reply

yefu.chen@zilliz.com
